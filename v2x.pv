(*定義通道，ch_1安全通道用於和TA溝通，提供註冊服務，ch_2用於車輛之間交換訊息，ch_3功能和ch_1一致*)
free ch_1: channel[private].
free ch_2: channel.
free ch_3: channel[private].

(*各部件的私鑰*)
free p_t: bitstring[private].
free p_v: bitstring[private].
free p_u: bitstring[private].

(*車輛傳輸的密文，用於檢測協議ˇ是否安全*)
free s_msg:bitstring[private].

(*車輛間的通訊金鑰*)
free Sk_vu: bitstring[private].
free Sk_uv: bitstring[private].

(*車輛的ID*)
const ID_v: bitstring.
const ID_u: bitstring.

(* ECC 運算 *)
const P: bitstring.
fun mult(bitstring, bitstring): bitstring.

(* 數字運算 *)
fun mul(bitstring, bitstring): bitstring.
fun add(bitstring, bitstring): bitstring.


(* 對稱式加密 *)
type key.
fun senc(bitstring, key): bitstring.
reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.

(*DHKE*)
fun s_mul(bitstring,bitstring):key.

(*event 用於判斷事件是否發生*)
event init_proc_v(bitstring).
event init_proc_u(bitstring).
event term_proc_v(bitstring).
event term_proc_u(bitstring).

(*attacker 嘗試竊取指定訊息*)
query attacker(p_t).(*各部件的私鑰*)
query attacker(p_v).
query attacker(p_u).
query attacker(Sk_uv).(* 車輛間的通訊金鑰 *)
query attacker(Sk_vu).
query attacker(s_msg).(* 隱私訊息 *)
query x: bitstring; inj-event(term_proc_v(x)) ==> inj-event(init_proc_v(x)).(* 用於判斷事件使否有完整執行 *)
query x: bitstring; inj-event(term_proc_u(x)) ==> inj-event(init_proc_u(x)).


(*t流程*)
let process_t = 
    (*生成TA的公鑰以及私鑰*)
    new pf: bitstring;
    new pc: bitstring;
    let p_t = mul(pf, P) in
    let Q_t = mult(p_t, P) in

    (*接收到車輛 V 的註冊請求[1]，生成隨機數r_v製作車輛身分驗證參數 Ai_v 和 Ar_v*)
    in(ch_1, ID_v: bitstring);
    new r_v: bitstring;
    let Ai_v = mult(add(p_t, mult(ID_v, r_v)),P) in
    let Ar_v = mult(r_v, P) in
    (*回傳身分驗證參數給予車輛 V[2]*)
    out(ch_1, (Ai_v, Ar_v,Q_t));
    out(ch_3,(Q_t)).(*傳輸公鑰給予車輛u*)

(*V流程*)
let process_v(kc:key) =
    (*車輛V傳輸ID給T進行註冊[1],*)
    event init_proc_v(ID_v);
    out(ch_1, ID_v);
    
    (*接收到TA回傳的身分認證參數[2]，計算車輛私鑰p_v以及公鑰 Q_v*)
    in(ch_1, (Ai_v: bitstring, Ar_v: bitstring, Q_t:bitstring));
    new rv: bitstring;
    let p_v = mul(Ai_v, rv) in
    let Q_v = mult(p_v, P) in

    (*向其他車輛開始廣播[3]，使用團體金鑰kc加密車輛V的公鑰*)
    let E_Q_v = senc(Q_v, kc) in
    out(ch_2,(Ai_v, Ar_v, E_Q_v));

    (*收到車輛 u 的加密公鑰[5]，獲取原始公鑰，並且基於DHKE生成和 u 的會話金鑰*)
    in(ch_2, E_Q_u: bitstring);
    let Q_u = sdec(E_Q_u, kc) in
    let Sk_vu = s_mul(p_v, Q_u) in

    (*測試會話金鑰的安全性以及一致性，接收來自車輛 u 的訊息[6]，並驗證訊息是否一致*)
    in(ch_2, es_msg: bitstring);
    let temp_msg = sdec(es_msg, Sk_vu) in
    if temp_msg = s_msg then
        event term_proc_v(ID_v).(*如果訊息一致，就會觸發event term_proc_v*)

(*u流程*)
let process_u (kc:key)= 
    (*車輛U的初始化，生成自身的公鑰Q_u，向TA註冊流程省略 *)
    event init_proc_u(ID_u);
    let Q_u = mult(p_u, P) in
    in(ch_3, Q_t: bitstring);(*接收到TA的公鑰*)

    (*接收到車輛 V 的廣播[4]，並使用團體金鑰解開車輛加密的公鑰Q_v*)
    in(ch_2, (Ai_v: bitstring, Ar_v: bitstring, E_Q_v: bitstring));
    let Q_v = sdec(E_Q_v, kc) in

    (*透過傳輸的身分驗證參數，確保V確實有經過註冊，確認通過就將自身的公鑰加密傳輸給車輛V[5]*)
    if Ai_v = add(Q_t,mul(ID_v,Ar_v)) then
        let E_Q_u = senc(Q_u, kc) in
        let Sk_uv = s_mul(p_u,Q_v) in (*基於DHKE生成車輛 V 的會話金鑰*)
        out(ch_2, E_Q_u);

        (*將隱私訊息透過剛剛生成的通訊金鑰進行對稱式加密，並將其傳輸給車輛V[6]*)
        let es_msg = senc(s_msg, Sk_uv) in
        out(ch_2, es_msg);
        event term_proc_u(ID_u).

(*main process*)
process
    new kc: key;
    ((!process_t)|(process_v(kc))|(process_u(kc)))